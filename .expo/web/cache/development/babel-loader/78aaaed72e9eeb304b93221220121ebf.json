{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport getChildRouter from \"./getChildRouter\";\nimport getNavigationActionCreators from \"./routers/getNavigationActionCreators\";\nimport getChildrenNavigationCache from \"./getChildrenNavigationCache\";\nimport getEventManager from \"./getEventManager\";\n\nvar createParamGetter = function createParamGetter(route) {\n  return function (paramName, defaultValue) {\n    var params = route.params;\n\n    if (params && paramName in params) {\n      return params[paramName];\n    }\n\n    return defaultValue;\n  };\n};\n\nfunction _getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  var children = getChildrenNavigationCache(navigation);\n  var childRoute = navigation.state.routes.find(function (r) {\n    return r.key === childKey;\n  });\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  var childRouter = getChildRouter(navigation.router, childRoute.routeName);\n  var focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;\n\n  var actionCreators = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, navigation.actions), navigation.router.getActionCreators(childRoute, navigation.state.key)), childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}), getNavigationActionCreators(childRoute));\n\n  var actionHelpers = {};\n  Object.keys(actionCreators).forEach(function (actionName) {\n    actionHelpers[actionName] = function () {\n      var actionCreator = actionCreators[actionName];\n      var action = actionCreator.apply(void 0, arguments);\n      return navigation.dispatch(action);\n    };\n  });\n  var _isFirstRouteInParent = true;\n  var parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    _isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (children[childKey] && children[childKey].isFirstRouteInParent() === _isFirstRouteInParent) {\n    children[childKey] = _objectSpread(_objectSpread(_objectSpread({}, children[childKey]), actionHelpers), {}, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute)\n    });\n    return children[childKey];\n  } else {\n    var _getEventManager = getEventManager(childKey),\n        addListener = _getEventManager.addListener,\n        emit = _getEventManager.emit;\n\n    children[childKey] = _objectSpread(_objectSpread({}, actionHelpers), {}, {\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n      getChildNavigation: function getChildNavigation(grandChildKey) {\n        return _getChildNavigation(children[childKey], grandChildKey, function () {\n          var nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        });\n      },\n      isFocused: function isFocused() {\n        var currentNavigation = getCurrentParentNavigation();\n\n        if (!currentNavigation) {\n          return false;\n        }\n\n        var _currentNavigation$st = currentNavigation.state,\n            routes = _currentNavigation$st.routes,\n            index = _currentNavigation$st.index;\n\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n\n        if (routes[index].key === childKey) {\n          return true;\n        }\n\n        return false;\n      },\n      isFirstRouteInParent: function isFirstRouteInParent() {\n        return _isFirstRouteInParent;\n      },\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener: addListener,\n      emit: emit\n    });\n    return children[childKey];\n  }\n}\n\nexport default _getChildNavigation;","map":{"version":3,"sources":["getChildNavigation.js"],"names":["createParamGetter","route","params","paramName","children","getChildrenNavigationCache","childRoute","navigation","r","childRouter","getChildRouter","focusedGrandChildRoute","actionCreators","getNavigationActionCreators","actionHelpers","Object","actionName","actionCreator","action","isFirstRouteInParent","parentNavigation","getCurrentParentNavigation","state","router","actions","getParam","emit","getEventManager","getChildNavigation","grandChildKey","nav","isFocused","currentNavigation","index","routes","dispatch","getScreenProps","dangerouslyGetParent","addListener"],"mappings":"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","sourcesContent":["import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\n\nconst createParamGetter = (route) => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find((r) => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName);\n\n  // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n  const focusedGrandChildRoute =\n    childRoute.routes && typeof childRoute.index === 'number'\n      ? childRoute.routes[childRoute.index]\n      : null;\n\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter\n      ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)\n      : {}),\n    ...getNavigationActionCreators(childRoute),\n  };\n\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach((actionName) => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n\n  let isFirstRouteInParent = true;\n\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent =\n      parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (\n    children[childKey] &&\n    children[childKey].isFirstRouteInParent() === isFirstRouteInParent\n  ) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n    };\n    return children[childKey];\n  } else {\n    const { addListener, emit } = getEventManager(childKey);\n\n    children[childKey] = {\n      ...actionHelpers,\n\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n\n      getChildNavigation: (grandChildKey) =>\n        getChildNavigation(children[childKey], grandChildKey, () => {\n          const nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        }),\n\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const { routes, index } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit,\n    };\n\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;\n"]},"metadata":{},"sourceType":"module"}